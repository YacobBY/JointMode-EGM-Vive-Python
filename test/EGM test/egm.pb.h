// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#ifndef PROTOBUF_egm_2eproto__INCLUDED
#define PROTOBUF_egm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace abb {
namespace egm {
class EgmCartesian;
class EgmCartesianDefaultTypeInternal;
extern EgmCartesianDefaultTypeInternal _EgmCartesian_default_instance_;
class EgmCartesianSpeed;
class EgmCartesianSpeedDefaultTypeInternal;
extern EgmCartesianSpeedDefaultTypeInternal _EgmCartesianSpeed_default_instance_;
class EgmEuler;
class EgmEulerDefaultTypeInternal;
extern EgmEulerDefaultTypeInternal _EgmEuler_default_instance_;
class EgmExternalJoints;
class EgmExternalJointsDefaultTypeInternal;
extern EgmExternalJointsDefaultTypeInternal _EgmExternalJoints_default_instance_;
class EgmFeedBack;
class EgmFeedBackDefaultTypeInternal;
extern EgmFeedBackDefaultTypeInternal _EgmFeedBack_default_instance_;
class EgmHeader;
class EgmHeaderDefaultTypeInternal;
extern EgmHeaderDefaultTypeInternal _EgmHeader_default_instance_;
class EgmJoints;
class EgmJointsDefaultTypeInternal;
extern EgmJointsDefaultTypeInternal _EgmJoints_default_instance_;
class EgmMCIState;
class EgmMCIStateDefaultTypeInternal;
extern EgmMCIStateDefaultTypeInternal _EgmMCIState_default_instance_;
class EgmMotorState;
class EgmMotorStateDefaultTypeInternal;
extern EgmMotorStateDefaultTypeInternal _EgmMotorState_default_instance_;
class EgmPathCorr;
class EgmPathCorrDefaultTypeInternal;
extern EgmPathCorrDefaultTypeInternal _EgmPathCorr_default_instance_;
class EgmPlanned;
class EgmPlannedDefaultTypeInternal;
extern EgmPlannedDefaultTypeInternal _EgmPlanned_default_instance_;
class EgmPose;
class EgmPoseDefaultTypeInternal;
extern EgmPoseDefaultTypeInternal _EgmPose_default_instance_;
class EgmQuaternion;
class EgmQuaternionDefaultTypeInternal;
extern EgmQuaternionDefaultTypeInternal _EgmQuaternion_default_instance_;
class EgmRapidCtrlExecState;
class EgmRapidCtrlExecStateDefaultTypeInternal;
extern EgmRapidCtrlExecStateDefaultTypeInternal _EgmRapidCtrlExecState_default_instance_;
class EgmRobot;
class EgmRobotDefaultTypeInternal;
extern EgmRobotDefaultTypeInternal _EgmRobot_default_instance_;
class EgmSensor;
class EgmSensorDefaultTypeInternal;
extern EgmSensorDefaultTypeInternal _EgmSensor_default_instance_;
class EgmSensorPathCorr;
class EgmSensorPathCorrDefaultTypeInternal;
extern EgmSensorPathCorrDefaultTypeInternal _EgmSensorPathCorr_default_instance_;
class EgmSpeedRef;
class EgmSpeedRefDefaultTypeInternal;
extern EgmSpeedRefDefaultTypeInternal _EgmSpeedRef_default_instance_;
class EgmTestSignals;
class EgmTestSignalsDefaultTypeInternal;
extern EgmTestSignalsDefaultTypeInternal _EgmTestSignals_default_instance_;
}  // namespace egm
}  // namespace abb

namespace abb {
namespace egm {

namespace protobuf_egm_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_egm_2eproto

enum EgmHeader_MessageType {
  EgmHeader_MessageType_MSGTYPE_UNDEFINED = 0,
  EgmHeader_MessageType_MSGTYPE_COMMAND = 1,
  EgmHeader_MessageType_MSGTYPE_DATA = 2,
  EgmHeader_MessageType_MSGTYPE_CORRECTION = 3,
  EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION = 4
};
bool EgmHeader_MessageType_IsValid(int value);
const EgmHeader_MessageType EgmHeader_MessageType_MessageType_MIN = EgmHeader_MessageType_MSGTYPE_UNDEFINED;
const EgmHeader_MessageType EgmHeader_MessageType_MessageType_MAX = EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
const int EgmHeader_MessageType_MessageType_ARRAYSIZE = EgmHeader_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EgmHeader_MessageType_descriptor();
inline const ::std::string& EgmHeader_MessageType_Name(EgmHeader_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EgmHeader_MessageType_descriptor(), value);
}
inline bool EgmHeader_MessageType_Parse(
    const ::std::string& name, EgmHeader_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmHeader_MessageType>(
    EgmHeader_MessageType_descriptor(), name, value);
}
enum EgmMotorState_MotorStateType {
  EgmMotorState_MotorStateType_MOTORS_UNDEFINED = 0,
  EgmMotorState_MotorStateType_MOTORS_ON = 1,
  EgmMotorState_MotorStateType_MOTORS_OFF = 2
};
bool EgmMotorState_MotorStateType_IsValid(int value);
const EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MIN = EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
const EgmMotorState_MotorStateType EgmMotorState_MotorStateType_MotorStateType_MAX = EgmMotorState_MotorStateType_MOTORS_OFF;
const int EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE = EgmMotorState_MotorStateType_MotorStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EgmMotorState_MotorStateType_descriptor();
inline const ::std::string& EgmMotorState_MotorStateType_Name(EgmMotorState_MotorStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EgmMotorState_MotorStateType_descriptor(), value);
}
inline bool EgmMotorState_MotorStateType_Parse(
    const ::std::string& name, EgmMotorState_MotorStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmMotorState_MotorStateType>(
    EgmMotorState_MotorStateType_descriptor(), name, value);
}
enum EgmMCIState_MCIStateType {
  EgmMCIState_MCIStateType_MCI_UNDEFINED = 0,
  EgmMCIState_MCIStateType_MCI_ERROR = 1,
  EgmMCIState_MCIStateType_MCI_STOPPED = 2,
  EgmMCIState_MCIStateType_MCI_RUNNING = 3
};
bool EgmMCIState_MCIStateType_IsValid(int value);
const EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MIN = EgmMCIState_MCIStateType_MCI_UNDEFINED;
const EgmMCIState_MCIStateType EgmMCIState_MCIStateType_MCIStateType_MAX = EgmMCIState_MCIStateType_MCI_RUNNING;
const int EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE = EgmMCIState_MCIStateType_MCIStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EgmMCIState_MCIStateType_descriptor();
inline const ::std::string& EgmMCIState_MCIStateType_Name(EgmMCIState_MCIStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EgmMCIState_MCIStateType_descriptor(), value);
}
inline bool EgmMCIState_MCIStateType_Parse(
    const ::std::string& name, EgmMCIState_MCIStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmMCIState_MCIStateType>(
    EgmMCIState_MCIStateType_descriptor(), name, value);
}
enum EgmRapidCtrlExecState_RapidCtrlExecStateType {
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED = 0,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED = 1,
  EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING = 2
};
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value);
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX = EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
const int EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE = EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
inline const ::std::string& EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), value);
}
inline bool EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(
    const ::std::string& name, EgmRapidCtrlExecState_RapidCtrlExecStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EgmRapidCtrlExecState_RapidCtrlExecStateType>(
    EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor(), name, value);
}
// ===================================================================

class EgmHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmHeader) */ {
 public:
  EgmHeader();
  virtual ~EgmHeader();

  EgmHeader(const EgmHeader& from);

  inline EgmHeader& operator=(const EgmHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmHeader(EgmHeader&& from) noexcept
    : EgmHeader() {
    *this = ::std::move(from);
  }

  inline EgmHeader& operator=(EgmHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmHeader& default_instance();

  static inline const EgmHeader* internal_default_instance() {
    return reinterpret_cast<const EgmHeader*>(
               &_EgmHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(EgmHeader* other);
  friend void swap(EgmHeader& a, EgmHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmHeader& from);
  void MergeFrom(const EgmHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EgmHeader_MessageType MessageType;
  static const MessageType MSGTYPE_UNDEFINED =
    EgmHeader_MessageType_MSGTYPE_UNDEFINED;
  static const MessageType MSGTYPE_COMMAND =
    EgmHeader_MessageType_MSGTYPE_COMMAND;
  static const MessageType MSGTYPE_DATA =
    EgmHeader_MessageType_MSGTYPE_DATA;
  static const MessageType MSGTYPE_CORRECTION =
    EgmHeader_MessageType_MSGTYPE_CORRECTION;
  static const MessageType MSGTYPE_PATH_CORRECTION =
    EgmHeader_MessageType_MSGTYPE_PATH_CORRECTION;
  static inline bool MessageType_IsValid(int value) {
    return EgmHeader_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    EgmHeader_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    EgmHeader_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    EgmHeader_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return EgmHeader_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return EgmHeader_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return EgmHeader_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 seqno = 1;
  bool has_seqno() const;
  void clear_seqno();
  static const int kSeqnoFieldNumber = 1;
  ::google::protobuf::uint32 seqno() const;
  void set_seqno(::google::protobuf::uint32 value);

  // optional uint32 tm = 2;
  bool has_tm() const;
  void clear_tm();
  static const int kTmFieldNumber = 2;
  ::google::protobuf::uint32 tm() const;
  void set_tm(::google::protobuf::uint32 value);

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  bool has_mtype() const;
  void clear_mtype();
  static const int kMtypeFieldNumber = 3;
  ::abb::egm::EgmHeader_MessageType mtype() const;
  void set_mtype(::abb::egm::EgmHeader_MessageType value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmHeader)
 private:
  void set_has_seqno();
  void clear_has_seqno();
  void set_has_tm();
  void clear_has_tm();
  void set_has_mtype();
  void clear_has_mtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 seqno_;
  ::google::protobuf::uint32 tm_;
  int mtype_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmCartesian : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesian) */ {
 public:
  EgmCartesian();
  virtual ~EgmCartesian();

  EgmCartesian(const EgmCartesian& from);

  inline EgmCartesian& operator=(const EgmCartesian& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmCartesian(EgmCartesian&& from) noexcept
    : EgmCartesian() {
    *this = ::std::move(from);
  }

  inline EgmCartesian& operator=(EgmCartesian&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmCartesian& default_instance();

  static inline const EgmCartesian* internal_default_instance() {
    return reinterpret_cast<const EgmCartesian*>(
               &_EgmCartesian_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(EgmCartesian* other);
  friend void swap(EgmCartesian& a, EgmCartesian& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmCartesian* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmCartesian* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmCartesian& from);
  void MergeFrom(const EgmCartesian& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmCartesian* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesian)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmQuaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmQuaternion) */ {
 public:
  EgmQuaternion();
  virtual ~EgmQuaternion();

  EgmQuaternion(const EgmQuaternion& from);

  inline EgmQuaternion& operator=(const EgmQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmQuaternion(EgmQuaternion&& from) noexcept
    : EgmQuaternion() {
    *this = ::std::move(from);
  }

  inline EgmQuaternion& operator=(EgmQuaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmQuaternion& default_instance();

  static inline const EgmQuaternion* internal_default_instance() {
    return reinterpret_cast<const EgmQuaternion*>(
               &_EgmQuaternion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(EgmQuaternion* other);
  friend void swap(EgmQuaternion& a, EgmQuaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmQuaternion* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmQuaternion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmQuaternion& from);
  void MergeFrom(const EgmQuaternion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmQuaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double u0 = 1;
  bool has_u0() const;
  void clear_u0();
  static const int kU0FieldNumber = 1;
  double u0() const;
  void set_u0(double value);

  // required double u1 = 2;
  bool has_u1() const;
  void clear_u1();
  static const int kU1FieldNumber = 2;
  double u1() const;
  void set_u1(double value);

  // required double u2 = 3;
  bool has_u2() const;
  void clear_u2();
  static const int kU2FieldNumber = 3;
  double u2() const;
  void set_u2(double value);

  // required double u3 = 4;
  bool has_u3() const;
  void clear_u3();
  static const int kU3FieldNumber = 4;
  double u3() const;
  void set_u3(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmQuaternion)
 private:
  void set_has_u0();
  void clear_has_u0();
  void set_has_u1();
  void clear_has_u1();
  void set_has_u2();
  void clear_has_u2();
  void set_has_u3();
  void clear_has_u3();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double u0_;
  double u1_;
  double u2_;
  double u3_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmEuler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmEuler) */ {
 public:
  EgmEuler();
  virtual ~EgmEuler();

  EgmEuler(const EgmEuler& from);

  inline EgmEuler& operator=(const EgmEuler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmEuler(EgmEuler&& from) noexcept
    : EgmEuler() {
    *this = ::std::move(from);
  }

  inline EgmEuler& operator=(EgmEuler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmEuler& default_instance();

  static inline const EgmEuler* internal_default_instance() {
    return reinterpret_cast<const EgmEuler*>(
               &_EgmEuler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(EgmEuler* other);
  friend void swap(EgmEuler& a, EgmEuler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmEuler* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmEuler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmEuler& from);
  void MergeFrom(const EgmEuler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmEuler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmEuler)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPose) */ {
 public:
  EgmPose();
  virtual ~EgmPose();

  EgmPose(const EgmPose& from);

  inline EgmPose& operator=(const EgmPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmPose(EgmPose&& from) noexcept
    : EgmPose() {
    *this = ::std::move(from);
  }

  inline EgmPose& operator=(EgmPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmPose& default_instance();

  static inline const EgmPose* internal_default_instance() {
    return reinterpret_cast<const EgmPose*>(
               &_EgmPose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(EgmPose* other);
  friend void swap(EgmPose& a, EgmPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmPose* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmPose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmPose& from);
  void MergeFrom(const EgmPose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::abb::egm::EgmCartesian& pos() const;
  ::abb::egm::EgmCartesian* mutable_pos();
  ::abb::egm::EgmCartesian* release_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* pos);

  // optional .abb.egm.EgmQuaternion orient = 2;
  bool has_orient() const;
  void clear_orient();
  static const int kOrientFieldNumber = 2;
  const ::abb::egm::EgmQuaternion& orient() const;
  ::abb::egm::EgmQuaternion* mutable_orient();
  ::abb::egm::EgmQuaternion* release_orient();
  void set_allocated_orient(::abb::egm::EgmQuaternion* orient);

  // optional .abb.egm.EgmEuler euler = 3;
  bool has_euler() const;
  void clear_euler();
  static const int kEulerFieldNumber = 3;
  const ::abb::egm::EgmEuler& euler() const;
  ::abb::egm::EgmEuler* mutable_euler();
  ::abb::egm::EgmEuler* release_euler();
  void set_allocated_euler(::abb::egm::EgmEuler* euler);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPose)
 private:
  void set_has_pos();
  void clear_has_pos();
  void set_has_orient();
  void clear_has_orient();
  void set_has_euler();
  void clear_has_euler();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmCartesian* pos_;
  ::abb::egm::EgmQuaternion* orient_;
  ::abb::egm::EgmEuler* euler_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmCartesianSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmCartesianSpeed) */ {
 public:
  EgmCartesianSpeed();
  virtual ~EgmCartesianSpeed();

  EgmCartesianSpeed(const EgmCartesianSpeed& from);

  inline EgmCartesianSpeed& operator=(const EgmCartesianSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmCartesianSpeed(EgmCartesianSpeed&& from) noexcept
    : EgmCartesianSpeed() {
    *this = ::std::move(from);
  }

  inline EgmCartesianSpeed& operator=(EgmCartesianSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmCartesianSpeed& default_instance();

  static inline const EgmCartesianSpeed* internal_default_instance() {
    return reinterpret_cast<const EgmCartesianSpeed*>(
               &_EgmCartesianSpeed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(EgmCartesianSpeed* other);
  friend void swap(EgmCartesianSpeed& a, EgmCartesianSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmCartesianSpeed* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmCartesianSpeed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmCartesianSpeed& from);
  void MergeFrom(const EgmCartesianSpeed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmCartesianSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  double value(int index) const;
  void set_value(int index, double value);
  void add_value(double value);
  const ::google::protobuf::RepeatedField< double >&
      value() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmCartesianSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > value_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmJoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmJoints) */ {
 public:
  EgmJoints();
  virtual ~EgmJoints();

  EgmJoints(const EgmJoints& from);

  inline EgmJoints& operator=(const EgmJoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmJoints(EgmJoints&& from) noexcept
    : EgmJoints() {
    *this = ::std::move(from);
  }

  inline EgmJoints& operator=(EgmJoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmJoints& default_instance();

  static inline const EgmJoints* internal_default_instance() {
    return reinterpret_cast<const EgmJoints*>(
               &_EgmJoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(EgmJoints* other);
  friend void swap(EgmJoints& a, EgmJoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmJoints* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmJoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmJoints& from);
  void MergeFrom(const EgmJoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmJoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double joints = 1;
  int joints_size() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::google::protobuf::RepeatedField< double >&
      joints() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmJoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > joints_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmExternalJoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmExternalJoints) */ {
 public:
  EgmExternalJoints();
  virtual ~EgmExternalJoints();

  EgmExternalJoints(const EgmExternalJoints& from);

  inline EgmExternalJoints& operator=(const EgmExternalJoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmExternalJoints(EgmExternalJoints&& from) noexcept
    : EgmExternalJoints() {
    *this = ::std::move(from);
  }

  inline EgmExternalJoints& operator=(EgmExternalJoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmExternalJoints& default_instance();

  static inline const EgmExternalJoints* internal_default_instance() {
    return reinterpret_cast<const EgmExternalJoints*>(
               &_EgmExternalJoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(EgmExternalJoints* other);
  friend void swap(EgmExternalJoints& a, EgmExternalJoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmExternalJoints* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmExternalJoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmExternalJoints& from);
  void MergeFrom(const EgmExternalJoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmExternalJoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double joints = 1;
  int joints_size() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  double joints(int index) const;
  void set_joints(int index, double value);
  void add_joints(double value);
  const ::google::protobuf::RepeatedField< double >&
      joints() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmExternalJoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > joints_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmPlanned : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPlanned) */ {
 public:
  EgmPlanned();
  virtual ~EgmPlanned();

  EgmPlanned(const EgmPlanned& from);

  inline EgmPlanned& operator=(const EgmPlanned& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmPlanned(EgmPlanned&& from) noexcept
    : EgmPlanned() {
    *this = ::std::move(from);
  }

  inline EgmPlanned& operator=(EgmPlanned&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmPlanned& default_instance();

  static inline const EgmPlanned* internal_default_instance() {
    return reinterpret_cast<const EgmPlanned*>(
               &_EgmPlanned_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(EgmPlanned* other);
  friend void swap(EgmPlanned& a, EgmPlanned& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmPlanned* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmPlanned* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmPlanned& from);
  void MergeFrom(const EgmPlanned& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmPlanned* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  const ::abb::egm::EgmJoints& joints() const;
  ::abb::egm::EgmJoints* mutable_joints();
  ::abb::egm::EgmJoints* release_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);

  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian();
  static const int kCartesianFieldNumber = 2;
  const ::abb::egm::EgmPose& cartesian() const;
  ::abb::egm::EgmPose* mutable_cartesian();
  ::abb::egm::EgmPose* release_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* cartesian);

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  void clear_externaljoints();
  static const int kExternalJointsFieldNumber = 3;
  const ::abb::egm::EgmJoints& externaljoints() const;
  ::abb::egm::EgmJoints* mutable_externaljoints();
  ::abb::egm::EgmJoints* release_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPlanned)
 private:
  void set_has_joints();
  void clear_has_joints();
  void set_has_cartesian();
  void clear_has_cartesian();
  void set_has_externaljoints();
  void clear_has_externaljoints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmJoints* joints_;
  ::abb::egm::EgmPose* cartesian_;
  ::abb::egm::EgmJoints* externaljoints_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmSpeedRef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSpeedRef) */ {
 public:
  EgmSpeedRef();
  virtual ~EgmSpeedRef();

  EgmSpeedRef(const EgmSpeedRef& from);

  inline EgmSpeedRef& operator=(const EgmSpeedRef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmSpeedRef(EgmSpeedRef&& from) noexcept
    : EgmSpeedRef() {
    *this = ::std::move(from);
  }

  inline EgmSpeedRef& operator=(EgmSpeedRef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmSpeedRef& default_instance();

  static inline const EgmSpeedRef* internal_default_instance() {
    return reinterpret_cast<const EgmSpeedRef*>(
               &_EgmSpeedRef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(EgmSpeedRef* other);
  friend void swap(EgmSpeedRef& a, EgmSpeedRef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmSpeedRef* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmSpeedRef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmSpeedRef& from);
  void MergeFrom(const EgmSpeedRef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmSpeedRef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  const ::abb::egm::EgmJoints& joints() const;
  ::abb::egm::EgmJoints* mutable_joints();
  ::abb::egm::EgmJoints* release_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  bool has_cartesians() const;
  void clear_cartesians();
  static const int kCartesiansFieldNumber = 2;
  const ::abb::egm::EgmCartesianSpeed& cartesians() const;
  ::abb::egm::EgmCartesianSpeed* mutable_cartesians();
  ::abb::egm::EgmCartesianSpeed* release_cartesians();
  void set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* cartesians);

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  void clear_externaljoints();
  static const int kExternalJointsFieldNumber = 3;
  const ::abb::egm::EgmJoints& externaljoints() const;
  ::abb::egm::EgmJoints* mutable_externaljoints();
  ::abb::egm::EgmJoints* release_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSpeedRef)
 private:
  void set_has_joints();
  void clear_has_joints();
  void set_has_cartesians();
  void clear_has_cartesians();
  void set_has_externaljoints();
  void clear_has_externaljoints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmJoints* joints_;
  ::abb::egm::EgmCartesianSpeed* cartesians_;
  ::abb::egm::EgmJoints* externaljoints_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmPathCorr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmPathCorr) */ {
 public:
  EgmPathCorr();
  virtual ~EgmPathCorr();

  EgmPathCorr(const EgmPathCorr& from);

  inline EgmPathCorr& operator=(const EgmPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmPathCorr(EgmPathCorr&& from) noexcept
    : EgmPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmPathCorr& operator=(EgmPathCorr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmPathCorr& default_instance();

  static inline const EgmPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmPathCorr*>(
               &_EgmPathCorr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(EgmPathCorr* other);
  friend void swap(EgmPathCorr& a, EgmPathCorr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmPathCorr* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmPathCorr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmPathCorr& from);
  void MergeFrom(const EgmPathCorr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmPathCorr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .abb.egm.EgmCartesian pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  const ::abb::egm::EgmCartesian& pos() const;
  ::abb::egm::EgmCartesian* mutable_pos();
  ::abb::egm::EgmCartesian* release_pos();
  void set_allocated_pos(::abb::egm::EgmCartesian* pos);

  // required uint32 age = 2;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 2;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmPathCorr)
 private:
  void set_has_pos();
  void clear_has_pos();
  void set_has_age();
  void clear_has_age();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmCartesian* pos_;
  ::google::protobuf::uint32 age_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmFeedBack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmFeedBack) */ {
 public:
  EgmFeedBack();
  virtual ~EgmFeedBack();

  EgmFeedBack(const EgmFeedBack& from);

  inline EgmFeedBack& operator=(const EgmFeedBack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmFeedBack(EgmFeedBack&& from) noexcept
    : EgmFeedBack() {
    *this = ::std::move(from);
  }

  inline EgmFeedBack& operator=(EgmFeedBack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmFeedBack& default_instance();

  static inline const EgmFeedBack* internal_default_instance() {
    return reinterpret_cast<const EgmFeedBack*>(
               &_EgmFeedBack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(EgmFeedBack* other);
  friend void swap(EgmFeedBack& a, EgmFeedBack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmFeedBack* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmFeedBack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmFeedBack& from);
  void MergeFrom(const EgmFeedBack& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmFeedBack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmJoints joints = 1;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 1;
  const ::abb::egm::EgmJoints& joints() const;
  ::abb::egm::EgmJoints* mutable_joints();
  ::abb::egm::EgmJoints* release_joints();
  void set_allocated_joints(::abb::egm::EgmJoints* joints);

  // optional .abb.egm.EgmPose cartesian = 2;
  bool has_cartesian() const;
  void clear_cartesian();
  static const int kCartesianFieldNumber = 2;
  const ::abb::egm::EgmPose& cartesian() const;
  ::abb::egm::EgmPose* mutable_cartesian();
  ::abb::egm::EgmPose* release_cartesian();
  void set_allocated_cartesian(::abb::egm::EgmPose* cartesian);

  // optional .abb.egm.EgmJoints externalJoints = 3;
  bool has_externaljoints() const;
  void clear_externaljoints();
  static const int kExternalJointsFieldNumber = 3;
  const ::abb::egm::EgmJoints& externaljoints() const;
  ::abb::egm::EgmJoints* mutable_externaljoints();
  ::abb::egm::EgmJoints* release_externaljoints();
  void set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmFeedBack)
 private:
  void set_has_joints();
  void clear_has_joints();
  void set_has_cartesian();
  void clear_has_cartesian();
  void set_has_externaljoints();
  void clear_has_externaljoints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmJoints* joints_;
  ::abb::egm::EgmPose* cartesian_;
  ::abb::egm::EgmJoints* externaljoints_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmMotorState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMotorState) */ {
 public:
  EgmMotorState();
  virtual ~EgmMotorState();

  EgmMotorState(const EgmMotorState& from);

  inline EgmMotorState& operator=(const EgmMotorState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmMotorState(EgmMotorState&& from) noexcept
    : EgmMotorState() {
    *this = ::std::move(from);
  }

  inline EgmMotorState& operator=(EgmMotorState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmMotorState& default_instance();

  static inline const EgmMotorState* internal_default_instance() {
    return reinterpret_cast<const EgmMotorState*>(
               &_EgmMotorState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(EgmMotorState* other);
  friend void swap(EgmMotorState& a, EgmMotorState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmMotorState* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmMotorState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmMotorState& from);
  void MergeFrom(const EgmMotorState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmMotorState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EgmMotorState_MotorStateType MotorStateType;
  static const MotorStateType MOTORS_UNDEFINED =
    EgmMotorState_MotorStateType_MOTORS_UNDEFINED;
  static const MotorStateType MOTORS_ON =
    EgmMotorState_MotorStateType_MOTORS_ON;
  static const MotorStateType MOTORS_OFF =
    EgmMotorState_MotorStateType_MOTORS_OFF;
  static inline bool MotorStateType_IsValid(int value) {
    return EgmMotorState_MotorStateType_IsValid(value);
  }
  static const MotorStateType MotorStateType_MIN =
    EgmMotorState_MotorStateType_MotorStateType_MIN;
  static const MotorStateType MotorStateType_MAX =
    EgmMotorState_MotorStateType_MotorStateType_MAX;
  static const int MotorStateType_ARRAYSIZE =
    EgmMotorState_MotorStateType_MotorStateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotorStateType_descriptor() {
    return EgmMotorState_MotorStateType_descriptor();
  }
  static inline const ::std::string& MotorStateType_Name(MotorStateType value) {
    return EgmMotorState_MotorStateType_Name(value);
  }
  static inline bool MotorStateType_Parse(const ::std::string& name,
      MotorStateType* value) {
    return EgmMotorState_MotorStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::abb::egm::EgmMotorState_MotorStateType state() const;
  void set_state(::abb::egm::EgmMotorState_MotorStateType value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMotorState)
 private:
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int state_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmMCIState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmMCIState) */ {
 public:
  EgmMCIState();
  virtual ~EgmMCIState();

  EgmMCIState(const EgmMCIState& from);

  inline EgmMCIState& operator=(const EgmMCIState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmMCIState(EgmMCIState&& from) noexcept
    : EgmMCIState() {
    *this = ::std::move(from);
  }

  inline EgmMCIState& operator=(EgmMCIState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmMCIState& default_instance();

  static inline const EgmMCIState* internal_default_instance() {
    return reinterpret_cast<const EgmMCIState*>(
               &_EgmMCIState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(EgmMCIState* other);
  friend void swap(EgmMCIState& a, EgmMCIState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmMCIState* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmMCIState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmMCIState& from);
  void MergeFrom(const EgmMCIState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmMCIState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EgmMCIState_MCIStateType MCIStateType;
  static const MCIStateType MCI_UNDEFINED =
    EgmMCIState_MCIStateType_MCI_UNDEFINED;
  static const MCIStateType MCI_ERROR =
    EgmMCIState_MCIStateType_MCI_ERROR;
  static const MCIStateType MCI_STOPPED =
    EgmMCIState_MCIStateType_MCI_STOPPED;
  static const MCIStateType MCI_RUNNING =
    EgmMCIState_MCIStateType_MCI_RUNNING;
  static inline bool MCIStateType_IsValid(int value) {
    return EgmMCIState_MCIStateType_IsValid(value);
  }
  static const MCIStateType MCIStateType_MIN =
    EgmMCIState_MCIStateType_MCIStateType_MIN;
  static const MCIStateType MCIStateType_MAX =
    EgmMCIState_MCIStateType_MCIStateType_MAX;
  static const int MCIStateType_ARRAYSIZE =
    EgmMCIState_MCIStateType_MCIStateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MCIStateType_descriptor() {
    return EgmMCIState_MCIStateType_descriptor();
  }
  static inline const ::std::string& MCIStateType_Name(MCIStateType value) {
    return EgmMCIState_MCIStateType_Name(value);
  }
  static inline bool MCIStateType_Parse(const ::std::string& name,
      MCIStateType* value) {
    return EgmMCIState_MCIStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::abb::egm::EgmMCIState_MCIStateType state() const;
  void set_state(::abb::egm::EgmMCIState_MCIStateType value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmMCIState)
 private:
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int state_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmRapidCtrlExecState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRapidCtrlExecState) */ {
 public:
  EgmRapidCtrlExecState();
  virtual ~EgmRapidCtrlExecState();

  EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from);

  inline EgmRapidCtrlExecState& operator=(const EgmRapidCtrlExecState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmRapidCtrlExecState(EgmRapidCtrlExecState&& from) noexcept
    : EgmRapidCtrlExecState() {
    *this = ::std::move(from);
  }

  inline EgmRapidCtrlExecState& operator=(EgmRapidCtrlExecState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmRapidCtrlExecState& default_instance();

  static inline const EgmRapidCtrlExecState* internal_default_instance() {
    return reinterpret_cast<const EgmRapidCtrlExecState*>(
               &_EgmRapidCtrlExecState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(EgmRapidCtrlExecState* other);
  friend void swap(EgmRapidCtrlExecState& a, EgmRapidCtrlExecState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmRapidCtrlExecState* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmRapidCtrlExecState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmRapidCtrlExecState& from);
  void MergeFrom(const EgmRapidCtrlExecState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmRapidCtrlExecState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EgmRapidCtrlExecState_RapidCtrlExecStateType RapidCtrlExecStateType;
  static const RapidCtrlExecStateType RAPID_UNDEFINED =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_UNDEFINED;
  static const RapidCtrlExecStateType RAPID_STOPPED =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_STOPPED;
  static const RapidCtrlExecStateType RAPID_RUNNING =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RAPID_RUNNING;
  static inline bool RapidCtrlExecStateType_IsValid(int value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value);
  }
  static const RapidCtrlExecStateType RapidCtrlExecStateType_MIN =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MIN;
  static const RapidCtrlExecStateType RapidCtrlExecStateType_MAX =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_MAX;
  static const int RapidCtrlExecStateType_ARRAYSIZE =
    EgmRapidCtrlExecState_RapidCtrlExecStateType_RapidCtrlExecStateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RapidCtrlExecStateType_descriptor() {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
  }
  static inline const ::std::string& RapidCtrlExecStateType_Name(RapidCtrlExecStateType value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Name(value);
  }
  static inline bool RapidCtrlExecStateType_Parse(const ::std::string& name,
      RapidCtrlExecStateType* value) {
    return EgmRapidCtrlExecState_RapidCtrlExecStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType state() const;
  void set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRapidCtrlExecState)
 private:
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int state_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmTestSignals : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmTestSignals) */ {
 public:
  EgmTestSignals();
  virtual ~EgmTestSignals();

  EgmTestSignals(const EgmTestSignals& from);

  inline EgmTestSignals& operator=(const EgmTestSignals& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmTestSignals(EgmTestSignals&& from) noexcept
    : EgmTestSignals() {
    *this = ::std::move(from);
  }

  inline EgmTestSignals& operator=(EgmTestSignals&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmTestSignals& default_instance();

  static inline const EgmTestSignals* internal_default_instance() {
    return reinterpret_cast<const EgmTestSignals*>(
               &_EgmTestSignals_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(EgmTestSignals* other);
  friend void swap(EgmTestSignals& a, EgmTestSignals& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmTestSignals* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmTestSignals* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmTestSignals& from);
  void MergeFrom(const EgmTestSignals& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmTestSignals* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double signals = 1;
  int signals_size() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 1;
  double signals(int index) const;
  void set_signals(int index, double value);
  void add_signals(double value);
  const ::google::protobuf::RepeatedField< double >&
      signals() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_signals();

  // @@protoc_insertion_point(class_scope:abb.egm.EgmTestSignals)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > signals_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmRobot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmRobot) */ {
 public:
  EgmRobot();
  virtual ~EgmRobot();

  EgmRobot(const EgmRobot& from);

  inline EgmRobot& operator=(const EgmRobot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmRobot(EgmRobot&& from) noexcept
    : EgmRobot() {
    *this = ::std::move(from);
  }

  inline EgmRobot& operator=(EgmRobot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmRobot& default_instance();

  static inline const EgmRobot* internal_default_instance() {
    return reinterpret_cast<const EgmRobot*>(
               &_EgmRobot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(EgmRobot* other);
  friend void swap(EgmRobot& a, EgmRobot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmRobot* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmRobot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmRobot& from);
  void MergeFrom(const EgmRobot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmRobot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::abb::egm::EgmHeader& header() const;
  ::abb::egm::EgmHeader* mutable_header();
  ::abb::egm::EgmHeader* release_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  bool has_feedback() const;
  void clear_feedback();
  static const int kFeedBackFieldNumber = 2;
  const ::abb::egm::EgmFeedBack& feedback() const;
  ::abb::egm::EgmFeedBack* mutable_feedback();
  ::abb::egm::EgmFeedBack* release_feedback();
  void set_allocated_feedback(::abb::egm::EgmFeedBack* feedback);

  // optional .abb.egm.EgmPlanned planned = 3;
  bool has_planned() const;
  void clear_planned();
  static const int kPlannedFieldNumber = 3;
  const ::abb::egm::EgmPlanned& planned() const;
  ::abb::egm::EgmPlanned* mutable_planned();
  ::abb::egm::EgmPlanned* release_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* planned);

  // optional .abb.egm.EgmMotorState motorState = 4;
  bool has_motorstate() const;
  void clear_motorstate();
  static const int kMotorStateFieldNumber = 4;
  const ::abb::egm::EgmMotorState& motorstate() const;
  ::abb::egm::EgmMotorState* mutable_motorstate();
  ::abb::egm::EgmMotorState* release_motorstate();
  void set_allocated_motorstate(::abb::egm::EgmMotorState* motorstate);

  // optional .abb.egm.EgmMCIState mciState = 5;
  bool has_mcistate() const;
  void clear_mcistate();
  static const int kMciStateFieldNumber = 5;
  const ::abb::egm::EgmMCIState& mcistate() const;
  ::abb::egm::EgmMCIState* mutable_mcistate();
  ::abb::egm::EgmMCIState* release_mcistate();
  void set_allocated_mcistate(::abb::egm::EgmMCIState* mcistate);

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  bool has_testsignals() const;
  void clear_testsignals();
  static const int kTestSignalsFieldNumber = 7;
  const ::abb::egm::EgmTestSignals& testsignals() const;
  ::abb::egm::EgmTestSignals* mutable_testsignals();
  ::abb::egm::EgmTestSignals* release_testsignals();
  void set_allocated_testsignals(::abb::egm::EgmTestSignals* testsignals);

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  bool has_rapidexecstate() const;
  void clear_rapidexecstate();
  static const int kRapidExecStateFieldNumber = 8;
  const ::abb::egm::EgmRapidCtrlExecState& rapidexecstate() const;
  ::abb::egm::EgmRapidCtrlExecState* mutable_rapidexecstate();
  ::abb::egm::EgmRapidCtrlExecState* release_rapidexecstate();
  void set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* rapidexecstate);

  // optional bool mciConvergenceMet = 6;
  bool has_mciconvergencemet() const;
  void clear_mciconvergencemet();
  static const int kMciConvergenceMetFieldNumber = 6;
  bool mciconvergencemet() const;
  void set_mciconvergencemet(bool value);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmRobot)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_feedback();
  void clear_has_feedback();
  void set_has_planned();
  void clear_has_planned();
  void set_has_motorstate();
  void clear_has_motorstate();
  void set_has_mcistate();
  void clear_has_mcistate();
  void set_has_mciconvergencemet();
  void clear_has_mciconvergencemet();
  void set_has_testsignals();
  void clear_has_testsignals();
  void set_has_rapidexecstate();
  void clear_has_rapidexecstate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmHeader* header_;
  ::abb::egm::EgmFeedBack* feedback_;
  ::abb::egm::EgmPlanned* planned_;
  ::abb::egm::EgmMotorState* motorstate_;
  ::abb::egm::EgmMCIState* mcistate_;
  ::abb::egm::EgmTestSignals* testsignals_;
  ::abb::egm::EgmRapidCtrlExecState* rapidexecstate_;
  bool mciconvergencemet_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmSensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensor) */ {
 public:
  EgmSensor();
  virtual ~EgmSensor();

  EgmSensor(const EgmSensor& from);

  inline EgmSensor& operator=(const EgmSensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmSensor(EgmSensor&& from) noexcept
    : EgmSensor() {
    *this = ::std::move(from);
  }

  inline EgmSensor& operator=(EgmSensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmSensor& default_instance();

  static inline const EgmSensor* internal_default_instance() {
    return reinterpret_cast<const EgmSensor*>(
               &_EgmSensor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(EgmSensor* other);
  friend void swap(EgmSensor& a, EgmSensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmSensor* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmSensor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmSensor& from);
  void MergeFrom(const EgmSensor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmSensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::abb::egm::EgmHeader& header() const;
  ::abb::egm::EgmHeader* mutable_header();
  ::abb::egm::EgmHeader* release_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);

  // optional .abb.egm.EgmPlanned planned = 2;
  bool has_planned() const;
  void clear_planned();
  static const int kPlannedFieldNumber = 2;
  const ::abb::egm::EgmPlanned& planned() const;
  ::abb::egm::EgmPlanned* mutable_planned();
  ::abb::egm::EgmPlanned* release_planned();
  void set_allocated_planned(::abb::egm::EgmPlanned* planned);

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  bool has_speedref() const;
  void clear_speedref();
  static const int kSpeedRefFieldNumber = 3;
  const ::abb::egm::EgmSpeedRef& speedref() const;
  ::abb::egm::EgmSpeedRef* mutable_speedref();
  ::abb::egm::EgmSpeedRef* release_speedref();
  void set_allocated_speedref(::abb::egm::EgmSpeedRef* speedref);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensor)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_planned();
  void clear_has_planned();
  void set_has_speedref();
  void clear_has_speedref();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmHeader* header_;
  ::abb::egm::EgmPlanned* planned_;
  ::abb::egm::EgmSpeedRef* speedref_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EgmSensorPathCorr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:abb.egm.EgmSensorPathCorr) */ {
 public:
  EgmSensorPathCorr();
  virtual ~EgmSensorPathCorr();

  EgmSensorPathCorr(const EgmSensorPathCorr& from);

  inline EgmSensorPathCorr& operator=(const EgmSensorPathCorr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EgmSensorPathCorr(EgmSensorPathCorr&& from) noexcept
    : EgmSensorPathCorr() {
    *this = ::std::move(from);
  }

  inline EgmSensorPathCorr& operator=(EgmSensorPathCorr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EgmSensorPathCorr& default_instance();

  static inline const EgmSensorPathCorr* internal_default_instance() {
    return reinterpret_cast<const EgmSensorPathCorr*>(
               &_EgmSensorPathCorr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(EgmSensorPathCorr* other);
  friend void swap(EgmSensorPathCorr& a, EgmSensorPathCorr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EgmSensorPathCorr* New() const PROTOBUF_FINAL { return New(NULL); }

  EgmSensorPathCorr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EgmSensorPathCorr& from);
  void MergeFrom(const EgmSensorPathCorr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EgmSensorPathCorr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.EgmHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::abb::egm::EgmHeader& header() const;
  ::abb::egm::EgmHeader* mutable_header();
  ::abb::egm::EgmHeader* release_header();
  void set_allocated_header(::abb::egm::EgmHeader* header);

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  bool has_pathcorr() const;
  void clear_pathcorr();
  static const int kPathCorrFieldNumber = 2;
  const ::abb::egm::EgmPathCorr& pathcorr() const;
  ::abb::egm::EgmPathCorr* mutable_pathcorr();
  ::abb::egm::EgmPathCorr* release_pathcorr();
  void set_allocated_pathcorr(::abb::egm::EgmPathCorr* pathcorr);

  // @@protoc_insertion_point(class_scope:abb.egm.EgmSensorPathCorr)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_pathcorr();
  void clear_has_pathcorr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::abb::egm::EgmHeader* header_;
  ::abb::egm::EgmPathCorr* pathcorr_;
  friend struct protobuf_egm_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EgmHeader

// optional uint32 seqno = 1;
inline bool EgmHeader::has_seqno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmHeader::set_has_seqno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmHeader::clear_has_seqno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmHeader::clear_seqno() {
  seqno_ = 0u;
  clear_has_seqno();
}
inline ::google::protobuf::uint32 EgmHeader::seqno() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.seqno)
  return seqno_;
}
inline void EgmHeader::set_seqno(::google::protobuf::uint32 value) {
  set_has_seqno();
  seqno_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.seqno)
}

// optional uint32 tm = 2;
inline bool EgmHeader::has_tm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmHeader::set_has_tm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmHeader::clear_has_tm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmHeader::clear_tm() {
  tm_ = 0u;
  clear_has_tm();
}
inline ::google::protobuf::uint32 EgmHeader::tm() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.tm)
  return tm_;
}
inline void EgmHeader::set_tm(::google::protobuf::uint32 value) {
  set_has_tm();
  tm_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.tm)
}

// optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
inline bool EgmHeader::has_mtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmHeader::set_has_mtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmHeader::clear_has_mtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmHeader::clear_mtype() {
  mtype_ = 0;
  clear_has_mtype();
}
inline ::abb::egm::EgmHeader_MessageType EgmHeader::mtype() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmHeader.mtype)
  return static_cast< ::abb::egm::EgmHeader_MessageType >(mtype_);
}
inline void EgmHeader::set_mtype(::abb::egm::EgmHeader_MessageType value) {
  assert(::abb::egm::EgmHeader_MessageType_IsValid(value));
  set_has_mtype();
  mtype_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmHeader.mtype)
}

// -------------------------------------------------------------------

// EgmCartesian

// required double x = 1;
inline bool EgmCartesian::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmCartesian::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmCartesian::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmCartesian::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double EgmCartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.x)
  return x_;
}
inline void EgmCartesian::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.x)
}

// required double y = 2;
inline bool EgmCartesian::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmCartesian::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmCartesian::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmCartesian::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double EgmCartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.y)
  return y_;
}
inline void EgmCartesian::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.y)
}

// required double z = 3;
inline bool EgmCartesian::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmCartesian::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmCartesian::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmCartesian::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double EgmCartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesian.z)
  return z_;
}
inline void EgmCartesian::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesian.z)
}

// -------------------------------------------------------------------

// EgmQuaternion

// required double u0 = 1;
inline bool EgmQuaternion::has_u0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmQuaternion::set_has_u0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmQuaternion::clear_has_u0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmQuaternion::clear_u0() {
  u0_ = 0;
  clear_has_u0();
}
inline double EgmQuaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u0)
  return u0_;
}
inline void EgmQuaternion::set_u0(double value) {
  set_has_u0();
  u0_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u0)
}

// required double u1 = 2;
inline bool EgmQuaternion::has_u1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmQuaternion::set_has_u1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmQuaternion::clear_has_u1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmQuaternion::clear_u1() {
  u1_ = 0;
  clear_has_u1();
}
inline double EgmQuaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u1)
  return u1_;
}
inline void EgmQuaternion::set_u1(double value) {
  set_has_u1();
  u1_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u1)
}

// required double u2 = 3;
inline bool EgmQuaternion::has_u2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmQuaternion::set_has_u2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmQuaternion::clear_has_u2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmQuaternion::clear_u2() {
  u2_ = 0;
  clear_has_u2();
}
inline double EgmQuaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u2)
  return u2_;
}
inline void EgmQuaternion::set_u2(double value) {
  set_has_u2();
  u2_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u2)
}

// required double u3 = 4;
inline bool EgmQuaternion::has_u3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EgmQuaternion::set_has_u3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EgmQuaternion::clear_has_u3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EgmQuaternion::clear_u3() {
  u3_ = 0;
  clear_has_u3();
}
inline double EgmQuaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmQuaternion.u3)
  return u3_;
}
inline void EgmQuaternion::set_u3(double value) {
  set_has_u3();
  u3_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmQuaternion.u3)
}

// -------------------------------------------------------------------

// EgmEuler

// required double x = 1;
inline bool EgmEuler::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmEuler::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmEuler::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmEuler::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double EgmEuler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.x)
  return x_;
}
inline void EgmEuler::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.x)
}

// required double y = 2;
inline bool EgmEuler::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmEuler::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmEuler::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmEuler::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double EgmEuler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.y)
  return y_;
}
inline void EgmEuler::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.y)
}

// required double z = 3;
inline bool EgmEuler::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmEuler::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmEuler::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmEuler::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double EgmEuler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmEuler.z)
  return z_;
}
inline void EgmEuler::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmEuler.z)
}

// -------------------------------------------------------------------

// EgmPose

// optional .abb.egm.EgmCartesian pos = 1;
inline bool EgmPose::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmPose::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmPose::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmPose::clear_pos() {
  if (pos_ != NULL) pos_->::abb::egm::EgmCartesian::Clear();
  clear_has_pos();
}
inline const ::abb::egm::EgmCartesian& EgmPose::pos() const {
  const ::abb::egm::EgmCartesian* p = pos_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmCartesian*>(
      &::abb::egm::_EgmCartesian_default_instance_);
}
inline ::abb::egm::EgmCartesian* EgmPose::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::abb::egm::EgmCartesian;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.pos)
  return pos_;
}
inline ::abb::egm::EgmCartesian* EgmPose::release_pos() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.pos)
  clear_has_pos();
  ::abb::egm::EgmCartesian* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void EgmPose::set_allocated_pos(::abb::egm::EgmCartesian* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.pos)
}

// optional .abb.egm.EgmQuaternion orient = 2;
inline bool EgmPose::has_orient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmPose::set_has_orient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmPose::clear_has_orient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmPose::clear_orient() {
  if (orient_ != NULL) orient_->::abb::egm::EgmQuaternion::Clear();
  clear_has_orient();
}
inline const ::abb::egm::EgmQuaternion& EgmPose::orient() const {
  const ::abb::egm::EgmQuaternion* p = orient_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.orient)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmQuaternion*>(
      &::abb::egm::_EgmQuaternion_default_instance_);
}
inline ::abb::egm::EgmQuaternion* EgmPose::mutable_orient() {
  set_has_orient();
  if (orient_ == NULL) {
    orient_ = new ::abb::egm::EgmQuaternion;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.orient)
  return orient_;
}
inline ::abb::egm::EgmQuaternion* EgmPose::release_orient() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.orient)
  clear_has_orient();
  ::abb::egm::EgmQuaternion* temp = orient_;
  orient_ = NULL;
  return temp;
}
inline void EgmPose::set_allocated_orient(::abb::egm::EgmQuaternion* orient) {
  delete orient_;
  orient_ = orient;
  if (orient) {
    set_has_orient();
  } else {
    clear_has_orient();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.orient)
}

// optional .abb.egm.EgmEuler euler = 3;
inline bool EgmPose::has_euler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmPose::set_has_euler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmPose::clear_has_euler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmPose::clear_euler() {
  if (euler_ != NULL) euler_->::abb::egm::EgmEuler::Clear();
  clear_has_euler();
}
inline const ::abb::egm::EgmEuler& EgmPose::euler() const {
  const ::abb::egm::EgmEuler* p = euler_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPose.euler)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmEuler*>(
      &::abb::egm::_EgmEuler_default_instance_);
}
inline ::abb::egm::EgmEuler* EgmPose::mutable_euler() {
  set_has_euler();
  if (euler_ == NULL) {
    euler_ = new ::abb::egm::EgmEuler;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPose.euler)
  return euler_;
}
inline ::abb::egm::EgmEuler* EgmPose::release_euler() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPose.euler)
  clear_has_euler();
  ::abb::egm::EgmEuler* temp = euler_;
  euler_ = NULL;
  return temp;
}
inline void EgmPose::set_allocated_euler(::abb::egm::EgmEuler* euler) {
  delete euler_;
  euler_ = euler;
  if (euler) {
    set_has_euler();
  } else {
    clear_has_euler();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPose.euler)
}

// -------------------------------------------------------------------

// EgmCartesianSpeed

// repeated double value = 1;
inline int EgmCartesianSpeed::value_size() const {
  return value_.size();
}
inline void EgmCartesianSpeed::clear_value() {
  value_.Clear();
}
inline double EgmCartesianSpeed::value(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmCartesianSpeed.value)
  return value_.Get(index);
}
inline void EgmCartesianSpeed::set_value(int index, double value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmCartesianSpeed.value)
}
inline void EgmCartesianSpeed::add_value(double value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmCartesianSpeed.value)
}
inline const ::google::protobuf::RepeatedField< double >&
EgmCartesianSpeed::value() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmCartesianSpeed.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< double >*
EgmCartesianSpeed::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmCartesianSpeed.value)
  return &value_;
}

// -------------------------------------------------------------------

// EgmJoints

// repeated double joints = 1;
inline int EgmJoints::joints_size() const {
  return joints_.size();
}
inline void EgmJoints::clear_joints() {
  joints_.Clear();
}
inline double EgmJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmJoints.joints)
  return joints_.Get(index);
}
inline void EgmJoints::set_joints(int index, double value) {
  joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmJoints.joints)
}
inline void EgmJoints::add_joints(double value) {
  joints_.Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmJoints.joints)
}
inline const ::google::protobuf::RepeatedField< double >&
EgmJoints::joints() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmJoints.joints)
  return joints_;
}
inline ::google::protobuf::RepeatedField< double >*
EgmJoints::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmJoints.joints)
  return &joints_;
}

// -------------------------------------------------------------------

// EgmExternalJoints

// repeated double joints = 1;
inline int EgmExternalJoints::joints_size() const {
  return joints_.size();
}
inline void EgmExternalJoints::clear_joints() {
  joints_.Clear();
}
inline double EgmExternalJoints::joints(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmExternalJoints.joints)
  return joints_.Get(index);
}
inline void EgmExternalJoints::set_joints(int index, double value) {
  joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmExternalJoints.joints)
}
inline void EgmExternalJoints::add_joints(double value) {
  joints_.Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmExternalJoints.joints)
}
inline const ::google::protobuf::RepeatedField< double >&
EgmExternalJoints::joints() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmExternalJoints.joints)
  return joints_;
}
inline ::google::protobuf::RepeatedField< double >*
EgmExternalJoints::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmExternalJoints.joints)
  return &joints_;
}

// -------------------------------------------------------------------

// EgmPlanned

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmPlanned::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmPlanned::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmPlanned::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmPlanned::clear_joints() {
  if (joints_ != NULL) joints_->::abb::egm::EgmJoints::Clear();
  clear_has_joints();
}
inline const ::abb::egm::EgmJoints& EgmPlanned::joints() const {
  const ::abb::egm::EgmJoints* p = joints_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.joints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmJoints*>(
      &::abb::egm::_EgmJoints_default_instance_);
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::abb::egm::EgmJoints;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.joints)
  return joints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.joints)
  clear_has_joints();
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void EgmPlanned::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmPlanned::has_cartesian() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmPlanned::set_has_cartesian() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmPlanned::clear_has_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmPlanned::clear_cartesian() {
  if (cartesian_ != NULL) cartesian_->::abb::egm::EgmPose::Clear();
  clear_has_cartesian();
}
inline const ::abb::egm::EgmPose& EgmPlanned::cartesian() const {
  const ::abb::egm::EgmPose* p = cartesian_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.cartesian)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmPose*>(
      &::abb::egm::_EgmPose_default_instance_);
}
inline ::abb::egm::EgmPose* EgmPlanned::mutable_cartesian() {
  set_has_cartesian();
  if (cartesian_ == NULL) {
    cartesian_ = new ::abb::egm::EgmPose;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.cartesian)
  return cartesian_;
}
inline ::abb::egm::EgmPose* EgmPlanned::release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.cartesian)
  clear_has_cartesian();
  ::abb::egm::EgmPose* temp = cartesian_;
  cartesian_ = NULL;
  return temp;
}
inline void EgmPlanned::set_allocated_cartesian(::abb::egm::EgmPose* cartesian) {
  delete cartesian_;
  cartesian_ = cartesian;
  if (cartesian) {
    set_has_cartesian();
  } else {
    clear_has_cartesian();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmPlanned::has_externaljoints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmPlanned::set_has_externaljoints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmPlanned::clear_has_externaljoints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmPlanned::clear_externaljoints() {
  if (externaljoints_ != NULL) externaljoints_->::abb::egm::EgmJoints::Clear();
  clear_has_externaljoints();
}
inline const ::abb::egm::EgmJoints& EgmPlanned::externaljoints() const {
  const ::abb::egm::EgmJoints* p = externaljoints_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPlanned.externalJoints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmJoints*>(
      &::abb::egm::_EgmJoints_default_instance_);
}
inline ::abb::egm::EgmJoints* EgmPlanned::mutable_externaljoints() {
  set_has_externaljoints();
  if (externaljoints_ == NULL) {
    externaljoints_ = new ::abb::egm::EgmJoints;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPlanned.externalJoints)
  return externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmPlanned::release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPlanned.externalJoints)
  clear_has_externaljoints();
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = NULL;
  return temp;
}
inline void EgmPlanned::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  delete externaljoints_;
  externaljoints_ = externaljoints;
  if (externaljoints) {
    set_has_externaljoints();
  } else {
    clear_has_externaljoints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPlanned.externalJoints)
}

// -------------------------------------------------------------------

// EgmSpeedRef

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmSpeedRef::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmSpeedRef::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmSpeedRef::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmSpeedRef::clear_joints() {
  if (joints_ != NULL) joints_->::abb::egm::EgmJoints::Clear();
  clear_has_joints();
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::joints() const {
  const ::abb::egm::EgmJoints* p = joints_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.joints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmJoints*>(
      &::abb::egm::_EgmJoints_default_instance_);
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::abb::egm::EgmJoints;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.joints)
  return joints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.joints)
  clear_has_joints();
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void EgmSpeedRef::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.joints)
}

// optional .abb.egm.EgmCartesianSpeed cartesians = 2;
inline bool EgmSpeedRef::has_cartesians() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmSpeedRef::set_has_cartesians() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmSpeedRef::clear_has_cartesians() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmSpeedRef::clear_cartesians() {
  if (cartesians_ != NULL) cartesians_->::abb::egm::EgmCartesianSpeed::Clear();
  clear_has_cartesians();
}
inline const ::abb::egm::EgmCartesianSpeed& EgmSpeedRef::cartesians() const {
  const ::abb::egm::EgmCartesianSpeed* p = cartesians_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.cartesians)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmCartesianSpeed*>(
      &::abb::egm::_EgmCartesianSpeed_default_instance_);
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::mutable_cartesians() {
  set_has_cartesians();
  if (cartesians_ == NULL) {
    cartesians_ = new ::abb::egm::EgmCartesianSpeed;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.cartesians)
  return cartesians_;
}
inline ::abb::egm::EgmCartesianSpeed* EgmSpeedRef::release_cartesians() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.cartesians)
  clear_has_cartesians();
  ::abb::egm::EgmCartesianSpeed* temp = cartesians_;
  cartesians_ = NULL;
  return temp;
}
inline void EgmSpeedRef::set_allocated_cartesians(::abb::egm::EgmCartesianSpeed* cartesians) {
  delete cartesians_;
  cartesians_ = cartesians;
  if (cartesians) {
    set_has_cartesians();
  } else {
    clear_has_cartesians();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.cartesians)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmSpeedRef::has_externaljoints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmSpeedRef::set_has_externaljoints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmSpeedRef::clear_has_externaljoints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmSpeedRef::clear_externaljoints() {
  if (externaljoints_ != NULL) externaljoints_->::abb::egm::EgmJoints::Clear();
  clear_has_externaljoints();
}
inline const ::abb::egm::EgmJoints& EgmSpeedRef::externaljoints() const {
  const ::abb::egm::EgmJoints* p = externaljoints_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSpeedRef.externalJoints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmJoints*>(
      &::abb::egm::_EgmJoints_default_instance_);
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::mutable_externaljoints() {
  set_has_externaljoints();
  if (externaljoints_ == NULL) {
    externaljoints_ = new ::abb::egm::EgmJoints;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSpeedRef.externalJoints)
  return externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmSpeedRef::release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSpeedRef.externalJoints)
  clear_has_externaljoints();
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = NULL;
  return temp;
}
inline void EgmSpeedRef::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  delete externaljoints_;
  externaljoints_ = externaljoints;
  if (externaljoints) {
    set_has_externaljoints();
  } else {
    clear_has_externaljoints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSpeedRef.externalJoints)
}

// -------------------------------------------------------------------

// EgmPathCorr

// required .abb.egm.EgmCartesian pos = 1;
inline bool EgmPathCorr::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmPathCorr::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmPathCorr::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmPathCorr::clear_pos() {
  if (pos_ != NULL) pos_->::abb::egm::EgmCartesian::Clear();
  clear_has_pos();
}
inline const ::abb::egm::EgmCartesian& EgmPathCorr::pos() const {
  const ::abb::egm::EgmCartesian* p = pos_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmCartesian*>(
      &::abb::egm::_EgmCartesian_default_instance_);
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::abb::egm::EgmCartesian;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmPathCorr.pos)
  return pos_;
}
inline ::abb::egm::EgmCartesian* EgmPathCorr::release_pos() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmPathCorr.pos)
  clear_has_pos();
  ::abb::egm::EgmCartesian* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void EgmPathCorr::set_allocated_pos(::abb::egm::EgmCartesian* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmPathCorr.pos)
}

// required uint32 age = 2;
inline bool EgmPathCorr::has_age() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmPathCorr::set_has_age() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmPathCorr::clear_has_age() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmPathCorr::clear_age() {
  age_ = 0u;
  clear_has_age();
}
inline ::google::protobuf::uint32 EgmPathCorr::age() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmPathCorr.age)
  return age_;
}
inline void EgmPathCorr::set_age(::google::protobuf::uint32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmPathCorr.age)
}

// -------------------------------------------------------------------

// EgmFeedBack

// optional .abb.egm.EgmJoints joints = 1;
inline bool EgmFeedBack::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmFeedBack::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmFeedBack::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmFeedBack::clear_joints() {
  if (joints_ != NULL) joints_->::abb::egm::EgmJoints::Clear();
  clear_has_joints();
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::joints() const {
  const ::abb::egm::EgmJoints* p = joints_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.joints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmJoints*>(
      &::abb::egm::_EgmJoints_default_instance_);
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::abb::egm::EgmJoints;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.joints)
  return joints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_joints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.joints)
  clear_has_joints();
  ::abb::egm::EgmJoints* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void EgmFeedBack::set_allocated_joints(::abb::egm::EgmJoints* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.joints)
}

// optional .abb.egm.EgmPose cartesian = 2;
inline bool EgmFeedBack::has_cartesian() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmFeedBack::set_has_cartesian() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmFeedBack::clear_has_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmFeedBack::clear_cartesian() {
  if (cartesian_ != NULL) cartesian_->::abb::egm::EgmPose::Clear();
  clear_has_cartesian();
}
inline const ::abb::egm::EgmPose& EgmFeedBack::cartesian() const {
  const ::abb::egm::EgmPose* p = cartesian_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.cartesian)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmPose*>(
      &::abb::egm::_EgmPose_default_instance_);
}
inline ::abb::egm::EgmPose* EgmFeedBack::mutable_cartesian() {
  set_has_cartesian();
  if (cartesian_ == NULL) {
    cartesian_ = new ::abb::egm::EgmPose;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.cartesian)
  return cartesian_;
}
inline ::abb::egm::EgmPose* EgmFeedBack::release_cartesian() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.cartesian)
  clear_has_cartesian();
  ::abb::egm::EgmPose* temp = cartesian_;
  cartesian_ = NULL;
  return temp;
}
inline void EgmFeedBack::set_allocated_cartesian(::abb::egm::EgmPose* cartesian) {
  delete cartesian_;
  cartesian_ = cartesian;
  if (cartesian) {
    set_has_cartesian();
  } else {
    clear_has_cartesian();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.cartesian)
}

// optional .abb.egm.EgmJoints externalJoints = 3;
inline bool EgmFeedBack::has_externaljoints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmFeedBack::set_has_externaljoints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmFeedBack::clear_has_externaljoints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmFeedBack::clear_externaljoints() {
  if (externaljoints_ != NULL) externaljoints_->::abb::egm::EgmJoints::Clear();
  clear_has_externaljoints();
}
inline const ::abb::egm::EgmJoints& EgmFeedBack::externaljoints() const {
  const ::abb::egm::EgmJoints* p = externaljoints_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmFeedBack.externalJoints)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmJoints*>(
      &::abb::egm::_EgmJoints_default_instance_);
}
inline ::abb::egm::EgmJoints* EgmFeedBack::mutable_externaljoints() {
  set_has_externaljoints();
  if (externaljoints_ == NULL) {
    externaljoints_ = new ::abb::egm::EgmJoints;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmFeedBack.externalJoints)
  return externaljoints_;
}
inline ::abb::egm::EgmJoints* EgmFeedBack::release_externaljoints() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmFeedBack.externalJoints)
  clear_has_externaljoints();
  ::abb::egm::EgmJoints* temp = externaljoints_;
  externaljoints_ = NULL;
  return temp;
}
inline void EgmFeedBack::set_allocated_externaljoints(::abb::egm::EgmJoints* externaljoints) {
  delete externaljoints_;
  externaljoints_ = externaljoints;
  if (externaljoints) {
    set_has_externaljoints();
  } else {
    clear_has_externaljoints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmFeedBack.externalJoints)
}

// -------------------------------------------------------------------

// EgmMotorState

// required .abb.egm.EgmMotorState.MotorStateType state = 1;
inline bool EgmMotorState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmMotorState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmMotorState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmMotorState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::abb::egm::EgmMotorState_MotorStateType EgmMotorState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMotorState.state)
  return static_cast< ::abb::egm::EgmMotorState_MotorStateType >(state_);
}
inline void EgmMotorState::set_state(::abb::egm::EgmMotorState_MotorStateType value) {
  assert(::abb::egm::EgmMotorState_MotorStateType_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmMotorState.state)
}

// -------------------------------------------------------------------

// EgmMCIState

// required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
inline bool EgmMCIState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmMCIState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmMCIState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmMCIState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::abb::egm::EgmMCIState_MCIStateType EgmMCIState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmMCIState.state)
  return static_cast< ::abb::egm::EgmMCIState_MCIStateType >(state_);
}
inline void EgmMCIState::set_state(::abb::egm::EgmMCIState_MCIStateType value) {
  assert(::abb::egm::EgmMCIState_MCIStateType_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmMCIState.state)
}

// -------------------------------------------------------------------

// EgmRapidCtrlExecState

// required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
inline bool EgmRapidCtrlExecState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmRapidCtrlExecState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmRapidCtrlExecState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmRapidCtrlExecState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::state() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRapidCtrlExecState.state)
  return static_cast< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType >(state_);
}
inline void EgmRapidCtrlExecState::set_state(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType value) {
  assert(::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmRapidCtrlExecState.state)
}

// -------------------------------------------------------------------

// EgmTestSignals

// repeated double signals = 1;
inline int EgmTestSignals::signals_size() const {
  return signals_.size();
}
inline void EgmTestSignals::clear_signals() {
  signals_.Clear();
}
inline double EgmTestSignals::signals(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmTestSignals.signals)
  return signals_.Get(index);
}
inline void EgmTestSignals::set_signals(int index, double value) {
  signals_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.EgmTestSignals.signals)
}
inline void EgmTestSignals::add_signals(double value) {
  signals_.Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.EgmTestSignals.signals)
}
inline const ::google::protobuf::RepeatedField< double >&
EgmTestSignals::signals() const {
  // @@protoc_insertion_point(field_list:abb.egm.EgmTestSignals.signals)
  return signals_;
}
inline ::google::protobuf::RepeatedField< double >*
EgmTestSignals::mutable_signals() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.EgmTestSignals.signals)
  return &signals_;
}

// -------------------------------------------------------------------

// EgmRobot

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmRobot::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmRobot::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmRobot::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmRobot::clear_header() {
  if (header_ != NULL) header_->::abb::egm::EgmHeader::Clear();
  clear_has_header();
}
inline const ::abb::egm::EgmHeader& EgmRobot::header() const {
  const ::abb::egm::EgmHeader* p = header_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.header)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmHeader*>(
      &::abb::egm::_EgmHeader_default_instance_);
}
inline ::abb::egm::EgmHeader* EgmRobot::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::abb::egm::EgmHeader;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.header)
  return header_;
}
inline ::abb::egm::EgmHeader* EgmRobot::release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.header)
  clear_has_header();
  ::abb::egm::EgmHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_header(::abb::egm::EgmHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.header)
}

// optional .abb.egm.EgmFeedBack feedBack = 2;
inline bool EgmRobot::has_feedback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmRobot::set_has_feedback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmRobot::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmRobot::clear_feedback() {
  if (feedback_ != NULL) feedback_->::abb::egm::EgmFeedBack::Clear();
  clear_has_feedback();
}
inline const ::abb::egm::EgmFeedBack& EgmRobot::feedback() const {
  const ::abb::egm::EgmFeedBack* p = feedback_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.feedBack)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmFeedBack*>(
      &::abb::egm::_EgmFeedBack_default_instance_);
}
inline ::abb::egm::EgmFeedBack* EgmRobot::mutable_feedback() {
  set_has_feedback();
  if (feedback_ == NULL) {
    feedback_ = new ::abb::egm::EgmFeedBack;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.feedBack)
  return feedback_;
}
inline ::abb::egm::EgmFeedBack* EgmRobot::release_feedback() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.feedBack)
  clear_has_feedback();
  ::abb::egm::EgmFeedBack* temp = feedback_;
  feedback_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_feedback(::abb::egm::EgmFeedBack* feedback) {
  delete feedback_;
  feedback_ = feedback;
  if (feedback) {
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.feedBack)
}

// optional .abb.egm.EgmPlanned planned = 3;
inline bool EgmRobot::has_planned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmRobot::set_has_planned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmRobot::clear_has_planned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmRobot::clear_planned() {
  if (planned_ != NULL) planned_->::abb::egm::EgmPlanned::Clear();
  clear_has_planned();
}
inline const ::abb::egm::EgmPlanned& EgmRobot::planned() const {
  const ::abb::egm::EgmPlanned* p = planned_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.planned)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmPlanned*>(
      &::abb::egm::_EgmPlanned_default_instance_);
}
inline ::abb::egm::EgmPlanned* EgmRobot::mutable_planned() {
  set_has_planned();
  if (planned_ == NULL) {
    planned_ = new ::abb::egm::EgmPlanned;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.planned)
  return planned_;
}
inline ::abb::egm::EgmPlanned* EgmRobot::release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.planned)
  clear_has_planned();
  ::abb::egm::EgmPlanned* temp = planned_;
  planned_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_planned(::abb::egm::EgmPlanned* planned) {
  delete planned_;
  planned_ = planned;
  if (planned) {
    set_has_planned();
  } else {
    clear_has_planned();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.planned)
}

// optional .abb.egm.EgmMotorState motorState = 4;
inline bool EgmRobot::has_motorstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EgmRobot::set_has_motorstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EgmRobot::clear_has_motorstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EgmRobot::clear_motorstate() {
  if (motorstate_ != NULL) motorstate_->::abb::egm::EgmMotorState::Clear();
  clear_has_motorstate();
}
inline const ::abb::egm::EgmMotorState& EgmRobot::motorstate() const {
  const ::abb::egm::EgmMotorState* p = motorstate_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.motorState)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmMotorState*>(
      &::abb::egm::_EgmMotorState_default_instance_);
}
inline ::abb::egm::EgmMotorState* EgmRobot::mutable_motorstate() {
  set_has_motorstate();
  if (motorstate_ == NULL) {
    motorstate_ = new ::abb::egm::EgmMotorState;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.motorState)
  return motorstate_;
}
inline ::abb::egm::EgmMotorState* EgmRobot::release_motorstate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.motorState)
  clear_has_motorstate();
  ::abb::egm::EgmMotorState* temp = motorstate_;
  motorstate_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_motorstate(::abb::egm::EgmMotorState* motorstate) {
  delete motorstate_;
  motorstate_ = motorstate;
  if (motorstate) {
    set_has_motorstate();
  } else {
    clear_has_motorstate();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.motorState)
}

// optional .abb.egm.EgmMCIState mciState = 5;
inline bool EgmRobot::has_mcistate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EgmRobot::set_has_mcistate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EgmRobot::clear_has_mcistate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EgmRobot::clear_mcistate() {
  if (mcistate_ != NULL) mcistate_->::abb::egm::EgmMCIState::Clear();
  clear_has_mcistate();
}
inline const ::abb::egm::EgmMCIState& EgmRobot::mcistate() const {
  const ::abb::egm::EgmMCIState* p = mcistate_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciState)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmMCIState*>(
      &::abb::egm::_EgmMCIState_default_instance_);
}
inline ::abb::egm::EgmMCIState* EgmRobot::mutable_mcistate() {
  set_has_mcistate();
  if (mcistate_ == NULL) {
    mcistate_ = new ::abb::egm::EgmMCIState;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.mciState)
  return mcistate_;
}
inline ::abb::egm::EgmMCIState* EgmRobot::release_mcistate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.mciState)
  clear_has_mcistate();
  ::abb::egm::EgmMCIState* temp = mcistate_;
  mcistate_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_mcistate(::abb::egm::EgmMCIState* mcistate) {
  delete mcistate_;
  mcistate_ = mcistate;
  if (mcistate) {
    set_has_mcistate();
  } else {
    clear_has_mcistate();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.mciState)
}

// optional bool mciConvergenceMet = 6;
inline bool EgmRobot::has_mciconvergencemet() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EgmRobot::set_has_mciconvergencemet() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EgmRobot::clear_has_mciconvergencemet() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EgmRobot::clear_mciconvergencemet() {
  mciconvergencemet_ = false;
  clear_has_mciconvergencemet();
}
inline bool EgmRobot::mciconvergencemet() const {
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.mciConvergenceMet)
  return mciconvergencemet_;
}
inline void EgmRobot::set_mciconvergencemet(bool value) {
  set_has_mciconvergencemet();
  mciconvergencemet_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.EgmRobot.mciConvergenceMet)
}

// optional .abb.egm.EgmTestSignals testSignals = 7;
inline bool EgmRobot::has_testsignals() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EgmRobot::set_has_testsignals() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EgmRobot::clear_has_testsignals() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EgmRobot::clear_testsignals() {
  if (testsignals_ != NULL) testsignals_->::abb::egm::EgmTestSignals::Clear();
  clear_has_testsignals();
}
inline const ::abb::egm::EgmTestSignals& EgmRobot::testsignals() const {
  const ::abb::egm::EgmTestSignals* p = testsignals_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.testSignals)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmTestSignals*>(
      &::abb::egm::_EgmTestSignals_default_instance_);
}
inline ::abb::egm::EgmTestSignals* EgmRobot::mutable_testsignals() {
  set_has_testsignals();
  if (testsignals_ == NULL) {
    testsignals_ = new ::abb::egm::EgmTestSignals;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.testSignals)
  return testsignals_;
}
inline ::abb::egm::EgmTestSignals* EgmRobot::release_testsignals() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.testSignals)
  clear_has_testsignals();
  ::abb::egm::EgmTestSignals* temp = testsignals_;
  testsignals_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_testsignals(::abb::egm::EgmTestSignals* testsignals) {
  delete testsignals_;
  testsignals_ = testsignals;
  if (testsignals) {
    set_has_testsignals();
  } else {
    clear_has_testsignals();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.testSignals)
}

// optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
inline bool EgmRobot::has_rapidexecstate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EgmRobot::set_has_rapidexecstate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EgmRobot::clear_has_rapidexecstate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EgmRobot::clear_rapidexecstate() {
  if (rapidexecstate_ != NULL) rapidexecstate_->::abb::egm::EgmRapidCtrlExecState::Clear();
  clear_has_rapidexecstate();
}
inline const ::abb::egm::EgmRapidCtrlExecState& EgmRobot::rapidexecstate() const {
  const ::abb::egm::EgmRapidCtrlExecState* p = rapidexecstate_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmRobot.rapidExecState)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmRapidCtrlExecState*>(
      &::abb::egm::_EgmRapidCtrlExecState_default_instance_);
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::mutable_rapidexecstate() {
  set_has_rapidexecstate();
  if (rapidexecstate_ == NULL) {
    rapidexecstate_ = new ::abb::egm::EgmRapidCtrlExecState;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmRobot.rapidExecState)
  return rapidexecstate_;
}
inline ::abb::egm::EgmRapidCtrlExecState* EgmRobot::release_rapidexecstate() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmRobot.rapidExecState)
  clear_has_rapidexecstate();
  ::abb::egm::EgmRapidCtrlExecState* temp = rapidexecstate_;
  rapidexecstate_ = NULL;
  return temp;
}
inline void EgmRobot::set_allocated_rapidexecstate(::abb::egm::EgmRapidCtrlExecState* rapidexecstate) {
  delete rapidexecstate_;
  rapidexecstate_ = rapidexecstate;
  if (rapidexecstate) {
    set_has_rapidexecstate();
  } else {
    clear_has_rapidexecstate();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmRobot.rapidExecState)
}

// -------------------------------------------------------------------

// EgmSensor

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensor::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmSensor::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmSensor::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmSensor::clear_header() {
  if (header_ != NULL) header_->::abb::egm::EgmHeader::Clear();
  clear_has_header();
}
inline const ::abb::egm::EgmHeader& EgmSensor::header() const {
  const ::abb::egm::EgmHeader* p = header_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.header)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmHeader*>(
      &::abb::egm::_EgmHeader_default_instance_);
}
inline ::abb::egm::EgmHeader* EgmSensor::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::abb::egm::EgmHeader;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.header)
  return header_;
}
inline ::abb::egm::EgmHeader* EgmSensor::release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.header)
  clear_has_header();
  ::abb::egm::EgmHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EgmSensor::set_allocated_header(::abb::egm::EgmHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.header)
}

// optional .abb.egm.EgmPlanned planned = 2;
inline bool EgmSensor::has_planned() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmSensor::set_has_planned() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmSensor::clear_has_planned() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmSensor::clear_planned() {
  if (planned_ != NULL) planned_->::abb::egm::EgmPlanned::Clear();
  clear_has_planned();
}
inline const ::abb::egm::EgmPlanned& EgmSensor::planned() const {
  const ::abb::egm::EgmPlanned* p = planned_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.planned)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmPlanned*>(
      &::abb::egm::_EgmPlanned_default_instance_);
}
inline ::abb::egm::EgmPlanned* EgmSensor::mutable_planned() {
  set_has_planned();
  if (planned_ == NULL) {
    planned_ = new ::abb::egm::EgmPlanned;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.planned)
  return planned_;
}
inline ::abb::egm::EgmPlanned* EgmSensor::release_planned() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.planned)
  clear_has_planned();
  ::abb::egm::EgmPlanned* temp = planned_;
  planned_ = NULL;
  return temp;
}
inline void EgmSensor::set_allocated_planned(::abb::egm::EgmPlanned* planned) {
  delete planned_;
  planned_ = planned;
  if (planned) {
    set_has_planned();
  } else {
    clear_has_planned();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.planned)
}

// optional .abb.egm.EgmSpeedRef speedRef = 3;
inline bool EgmSensor::has_speedref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EgmSensor::set_has_speedref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EgmSensor::clear_has_speedref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EgmSensor::clear_speedref() {
  if (speedref_ != NULL) speedref_->::abb::egm::EgmSpeedRef::Clear();
  clear_has_speedref();
}
inline const ::abb::egm::EgmSpeedRef& EgmSensor::speedref() const {
  const ::abb::egm::EgmSpeedRef* p = speedref_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensor.speedRef)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmSpeedRef*>(
      &::abb::egm::_EgmSpeedRef_default_instance_);
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::mutable_speedref() {
  set_has_speedref();
  if (speedref_ == NULL) {
    speedref_ = new ::abb::egm::EgmSpeedRef;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensor.speedRef)
  return speedref_;
}
inline ::abb::egm::EgmSpeedRef* EgmSensor::release_speedref() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensor.speedRef)
  clear_has_speedref();
  ::abb::egm::EgmSpeedRef* temp = speedref_;
  speedref_ = NULL;
  return temp;
}
inline void EgmSensor::set_allocated_speedref(::abb::egm::EgmSpeedRef* speedref) {
  delete speedref_;
  speedref_ = speedref;
  if (speedref) {
    set_has_speedref();
  } else {
    clear_has_speedref();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensor.speedRef)
}

// -------------------------------------------------------------------

// EgmSensorPathCorr

// optional .abb.egm.EgmHeader header = 1;
inline bool EgmSensorPathCorr::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EgmSensorPathCorr::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EgmSensorPathCorr::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EgmSensorPathCorr::clear_header() {
  if (header_ != NULL) header_->::abb::egm::EgmHeader::Clear();
  clear_has_header();
}
inline const ::abb::egm::EgmHeader& EgmSensorPathCorr::header() const {
  const ::abb::egm::EgmHeader* p = header_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.header)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmHeader*>(
      &::abb::egm::_EgmHeader_default_instance_);
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::abb::egm::EgmHeader;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.header)
  return header_;
}
inline ::abb::egm::EgmHeader* EgmSensorPathCorr::release_header() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.header)
  clear_has_header();
  ::abb::egm::EgmHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EgmSensorPathCorr::set_allocated_header(::abb::egm::EgmHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.header)
}

// optional .abb.egm.EgmPathCorr pathCorr = 2;
inline bool EgmSensorPathCorr::has_pathcorr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EgmSensorPathCorr::set_has_pathcorr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EgmSensorPathCorr::clear_has_pathcorr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EgmSensorPathCorr::clear_pathcorr() {
  if (pathcorr_ != NULL) pathcorr_->::abb::egm::EgmPathCorr::Clear();
  clear_has_pathcorr();
}
inline const ::abb::egm::EgmPathCorr& EgmSensorPathCorr::pathcorr() const {
  const ::abb::egm::EgmPathCorr* p = pathcorr_;
  // @@protoc_insertion_point(field_get:abb.egm.EgmSensorPathCorr.pathCorr)
  return p != NULL ? *p : *reinterpret_cast<const ::abb::egm::EgmPathCorr*>(
      &::abb::egm::_EgmPathCorr_default_instance_);
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::mutable_pathcorr() {
  set_has_pathcorr();
  if (pathcorr_ == NULL) {
    pathcorr_ = new ::abb::egm::EgmPathCorr;
  }
  // @@protoc_insertion_point(field_mutable:abb.egm.EgmSensorPathCorr.pathCorr)
  return pathcorr_;
}
inline ::abb::egm::EgmPathCorr* EgmSensorPathCorr::release_pathcorr() {
  // @@protoc_insertion_point(field_release:abb.egm.EgmSensorPathCorr.pathCorr)
  clear_has_pathcorr();
  ::abb::egm::EgmPathCorr* temp = pathcorr_;
  pathcorr_ = NULL;
  return temp;
}
inline void EgmSensorPathCorr::set_allocated_pathcorr(::abb::egm::EgmPathCorr* pathcorr) {
  delete pathcorr_;
  pathcorr_ = pathcorr;
  if (pathcorr) {
    set_has_pathcorr();
  } else {
    clear_has_pathcorr();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.EgmSensorPathCorr.pathCorr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace egm
}  // namespace abb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::abb::egm::EgmHeader_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmHeader_MessageType>() {
  return ::abb::egm::EgmHeader_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmMotorState_MotorStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmMotorState_MotorStateType>() {
  return ::abb::egm::EgmMotorState_MotorStateType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmMCIState_MCIStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmMCIState_MCIStateType>() {
  return ::abb::egm::EgmMCIState_MCIStateType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType>() {
  return ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_egm_2eproto__INCLUDED
