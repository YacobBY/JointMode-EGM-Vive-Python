#include <Python.h>
#include <boost/python.hpp>

#include <WinSock2.h>
#include <iostream>
#include <fstream>

#include "egm.pb.h" // generated by Google protoc.exe

#pragma comment(lib, "Ws2_32.lib")      // socket lib
#pragma comment(lib, "libprotobuf.lib") // protobuf lib


static int portNumber = 6510;
static unsigned int sequenceNumber = 0;

//using namespace std;
using namespace abb::egm;
namespace py = boost::python;

class Robot_EGM {
public:
    Robot_EGM();
    bool loop();
    void setOffset(py::list p, py::list q);
    py::list getJoints();
    int getSeqno();
    bool connect();
    bool egm_connected=false;
private:
    void CreateSensorMessage(EgmSensor* pSensorMessage);
    int DisplayRobotMessage(EgmRobot *pRobotMessage);
    SOCKET sockfd;
    int n;
    struct sockaddr_in serverAddr, clientAddr;
    int len;
    char protoMessage[1400];
    /* Init winsock */
    WSADATA wsaData;
    double offset_x=0;
    double offset_y=0;
    double offset_z=0;
    double q1=0;
    double q2=0;
    double q3=0;
    double q4=0;
    int connection_seqno;
    EgmFeedBack robot_feedback;
    EgmJoints egmjoints;
};


//**************************************************************
//**************************************************************


Robot_EGM::Robot_EGM()
{
}

bool Robot_EGM::connect()
{
    if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0)
    {
        fprintf(stderr, "Could not open Windows connection.\n");
        return false;
    }

    // create socket to listen on
    sockfd = ::socket(AF_INET,SOCK_DGRAM,0);

    memset(&serverAddr, sizeof(serverAddr), 0);
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddr.sin_port = htons(portNumber);

    // listen on all interfaces
    auto f = ::bind(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr));
    return true;
}

bool Robot_EGM::loop()
{
    std::string messageBuffer;
    // receive and display message from robot
    len = sizeof(clientAddr);
    n = recvfrom(sockfd, protoMessage, 1400, 0, (struct sockaddr *)&clientAddr, &len);

    if (n < 0)
    {
        printf("Error receive message\n");
        return false;
    }
    else
    {
        // deserialize inbound message
        EgmRobot *pRobotMessage = new EgmRobot();
        pRobotMessage->ParseFromArray(protoMessage, n);
        int message_result=DisplayRobotMessage(pRobotMessage);
        delete pRobotMessage;
        if (message_result==0) return 1;

        // create and send a sensor message
        EgmSensor *pSensorMessage = new EgmSensor();
        CreateSensorMessage(pSensorMessage);
        pSensorMessage->SerializeToString(&messageBuffer);

        // send a message to the robot
        n = sendto(sockfd, messageBuffer.c_str(), messageBuffer.length(), 0, (struct sockaddr *)&clientAddr, sizeof(clientAddr));
        if (n < 0)
        {
            printf("Error send message\n");
            return false;
        }
        delete pSensorMessage;
        egm_connected=true;
        return true;
    }
}

//////////////////////////////////////////////////////////////////////////
// Create a simple sensor message
void Robot_EGM::CreateSensorMessage(EgmSensor* pSensorMessage)
{
    EgmHeader* header = new EgmHeader();
    header->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    header->set_seqno(sequenceNumber++);
    header->set_tm(GetTickCount());

    pSensorMessage->set_allocated_header(header);

    EgmCartesian *pc = new EgmCartesian();
    pc->set_x(offset_x);
    pc->set_y(offset_y);
    pc->set_z(offset_z);

    EgmQuaternion *pq = new EgmQuaternion();
    pq->set_u0(q1);
    pq->set_u1(q2);
    pq->set_u2(q3);
    pq->set_u3(q4);

    EgmPose *pcartesian = new EgmPose();
    pcartesian->set_allocated_orient(pq);
    pcartesian->set_allocated_pos(pc);

    EgmPlanned *planned = new EgmPlanned();
    planned->set_allocated_cartesian(pcartesian);

    pSensorMessage->set_allocated_planned(planned);
}

//////////////////////////////////////////////////////////////////////////
// Display inbound robot message
int Robot_EGM::DisplayRobotMessage(EgmRobot *pRobotMessage)
{
    if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype())
    {
        //printf("SeqNo=%d Tm=%u Type=%d\n", pRobotMessage->header().seqno(), pRobotMessage->header().tm(), pRobotMessage->header().mtype());
        connection_seqno=pRobotMessage->header().seqno();
        robot_feedback=pRobotMessage->feedback();
        egmjoints=robot_feedback.joints();
        return pRobotMessage->header().seqno();
    }
    else
    {
        printf("No header\n");
        return 0;
    }
}

void Robot_EGM::setOffset(py::list p,py::list q)
{
  if (egm_connected) {
    offset_x=py::extract<double>(p[0]);
    offset_y=py::extract<double>(p[1]);
    offset_z=py::extract<double>(p[2]);
    q1=py::extract<double>(q[0]);
    q2=py::extract<double>(q[1]);
    q3=py::extract<double>(q[2]);
    q4=py::extract<double>(q[3]);
  }
}

py::list Robot_EGM::getJoints()
{
	py::list joints;
  if (egm_connected) {
    joints.append(egmjoints.joints(0)*180/3.1415);
    joints.append(egmjoints.joints(1)*180/3.1415);
    joints.append(egmjoints.joints(2)*180/3.1415);
    joints.append(egmjoints.joints(3)*180/3.1415);
    joints.append(egmjoints.joints(4)*180/3.1415);
    joints.append(egmjoints.joints(5)*180/3.1415);
    return joints;
  }
  joints.append(0);
	return joints;
}

int Robot_EGM::getSeqno()
{
    n=connection_seqno;
	return n;
}

BOOST_PYTHON_MODULE(robot_egm){
  py::class_<Robot_EGM>("Robot_EGM")
	.def("loop", &Robot_EGM::loop)
	.def("connect", &Robot_EGM::connect)
	.def("setOffset", &Robot_EGM::setOffset)
    .def("getJoints", &Robot_EGM::getJoints)
	.def("getSeqno", &Robot_EGM::getSeqno);
}
